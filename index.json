[{"body":"","link":"https://www.professionaldev.pro/","section":"","tags":null,"title":""},{"body":"","link":"https://www.professionaldev.pro/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://www.professionaldev.pro/tags/hashmap/","section":"tags","tags":null,"title":"hashMap"},{"body":"Introduction By default, Microsoft SQL Server processes strings without considering their case sensitivity. Java, unlike Microsoft SQL Server, is case-sensitive which can result in problems. Specifically, on the project I'm working on, there have been numerous bugs caused by the mismatch in case sensitivity.\nGenerally, there are many situations where case-insensitive strings are necessary. One such example is with email addresses, which are inherently case-insensitive. Therefore, the issue of case sensitivity is not solely related to the mismatch between MS SQL Server and Java, but rather it is a more widespread concern.\nIn the following, I will explain how case sensitivity can cause issues in code, and how and why using a case-insensitive hash map can provide a solution.\nExample Let's say:\nThe groups API provides a service called GroupsService which accepts a list of user email addresses and creates a group with those users. Each user's email address is unique in the EmailGroups database. Another API called users is used to create new users with their email addresses and store them in a database. When a request is made to the GroupsService service, each email address in the list is validated by checking a database using a case-insensitive search. If an email address in the list is not found in the database, an error is thrown and the error message includes the exact email address that wasn't found. The GroupsService service is designed to handle large requests, so it employs a solution that checks email addresses in chunks, rather than one-by-one against the database. Implementation Retrieve emails (along with any other data necessary for processing the request) from the database by filtering them using the email addresses provided in the incoming request. Store the retrieved results in a Java HashMap. Iterate through each email address in the incoming request and check if there is a corresponding entry in the HashMap. If an entry doesn't exist for an email address, an error is thrown to the user. We can use the following Java code to implement described behaviour:\n1public class GroupsService { 2 @Value 3 private static class MemberInfo { 4 int id; 5 String email; 6 String name; 7 } 8 public void createGroupWithMembership(@NonNull String groupName, @NonNull List\u0026lt;String\u0026gt; memberEmails) { 9 Map\u0026lt;String, MemberInfo\u0026gt; stringMemberInfoMap = loadMemberInfoByEmails(memberEmails); 10 11 for (String memberEmail : memberEmails) { 12 if (!stringMemberInfoMap.containsKey(memberEmail)) { 13 throw new IllegalArgumentException(\u0026#34;Can\u0026#39;t find email: \u0026#39;%s\u0026#39; in the system.\u0026#34;); 14 } 15 } 16 17 } 18 19 private Map\u0026lt;String, MemberInfo\u0026gt; loadMemberInfoByEmails(List\u0026lt;String\u0026gt; memberEmails) { 20 List\u0026lt;String\u0026gt; memberEmailsToLookupFor = memberEmails.stream().distinct().sorted().toList(); 21 List\u0026lt;MemberInfo\u0026gt; memberInfoList = groupRepository.loadMemberInfoByEmails(memberEmailsToLookupFor); 22 return 23 memberInfoList 24 .stream() 25 .collect(Collectors.toMap(MemberInfo::getEmail, Function.identity())); 26 } 27} The Problem Since the database is case-insensitive, it will return all emails without considering the case of the input string. However, in Java, we use a HashMap to match incoming emails with emails from the database. The issue with this approach is that HashMap keys are case-sensitive, which means that some emails may not be found.\nTo illustrate the problem, consider the following example:\n1 INPUT LIST HASH MAP 2 (lower case emails) (case-sensitive email keys) 3 4 +------------------------+ +------------------------+ 5 | alice@example.com | | alice@example.com | MemberInfo 6 +------------------------+ +------------------------+ 7 | BOB@example.com (*) | | Bob@example.com | MemberInfo 8 +------------------------+ +------------------------+ 9 | charlie@example.com | | charlie@example.com | MemberInfo 10 +------------------------+ +------------------------+ 11 | DAVID@example.com (*) | | David@example.com | MemberInfo 12 +------------------------+ +------------------------+ Sure, here's a clearer rewrite of the text:\nIn the previous example, Bob and David have different casing in their email addresses. Because the hashCode function generates different hash codes for the same string with different casing, the hash map will not be able to find their email addresses in the database. This can lead to errors for the user, even though we have data about both email addresses in the database.\nSolution 1: Use TreeMap The solution to the problem of case-sensitive hash maps in Java is to use a TreeMap instead of a HashMap, as it can accept a custom comparator. By using a case-insensitive comparator, the TreeMap will be able to match email addresses with different casing, and the correct MemberInfo can be retrieved from the database. Here is an example of how to use a TreeMap with a custom comparator in Java:\n1Map\u0026lt;String, String\u0026gt; mapping = new TreeMap(String::caseInsensitiveComparator); While TreeMap offers good performance, it may not be as fast as HashMap for large datasets. The query time increases with the size of the dataset. However, searching the data using TreeMap is similar to performing a binary search, so the access time doesn't drop linearly. Although TreeMap provides good performance, it can't match the nearly constant O(1) access time of HashMap.\nSolution 2: Use HashMap Unfortunately, hash maps only work based on object hashCode and equals methods, and it doesn't allow for custom functions to be supplied at the constructor or in any other way. This can be limiting, and as a result, many programmers opt for TreeMap.\nHowever, as professional developers, we can create a better implementation for case-insensitive string equals and hash code methods. There are two main approaches:\nConvert all strings to lower/upper case. However, this creates a lot of new objects, which doubles memory usage, and we always need to lower/upper case input strings for the hash map. This can create memory churn in high-load scenarios, and it is also required to store strings with the original casing, so we need a way to map from lower/upper cased strings to the original ones. Due to all these challenges, this approach is not recommended.\nExtend the String class and override the hashCode and equals methods. Alternatively, we can create a new type, store the string as a final local variable, and implement custom equals and hashCode methods. This approach still requires the creation of new objects, but compared to creating new strings, memory allocation is much lower.\nThe challenge now is to implement those two methods. For equals, we can use the equalsIgnoreCase method instead of toLowerCase, which avoids the problems mentioned above. For the hashMethod, we can copy the logic from the String class and use the lowercase version of the characters for generating the hashCode. Here is an implementation example:\n1@RequiredArgsConstructor(staticName = \u0026#34;of\u0026#34;) 2public class CiString { 3 @NonNull 4 private final String stringVal; 5 private int hash = 0; 6 7 @Override 8 public boolean equals(Object o) { 9 if (this == o) return true; 10 11 if (o == null || getClass() != o.getClass()) return false; 12 CiString ciString = (CiString) o; 13 return stringVal.equalsIgnoreCase(ciString.toString()); 14 } 15 public int hashCode() { 16 int h = hash; 17 if (h == 0 \u0026amp;\u0026amp; stringVal.length() \u0026gt; 0) { 18 for (int i = 0; i \u0026lt; stringVal.length(); i++) { 19 h = 31 * h + Character.toLowerCase(stringVal.charAt(i)); 20 } 21 hash = h; 22 } 23 return h; 24 } 25 @Override 26 public String toString() { 27 return stringVal; 28 } 29} Furthermore, if our intention is to use the CiString class only as keys in a hash map, and we calculate the hash code only once, we can remove the private int hash property from the class. This optimization can conserve memory space since the hash code is only necessary for determining the bucket location in the hash map, and not for any other tasks.\nAs professional developers, it's important to write tests to ensure the correctness and reliability of our code. Here is an example of a test class for the case-insensitive string hash map implementation:\n1public class CiStringTest { 2 @Test 3 public void nvl() { 4 Assertions.assertNull(CiString.nvl(null)); 5 Assertions.assertNotNull(CiString.nvl(\u0026#34;\u0026#34;)); 6 } 7 @Test 8 public void testEquals() { 9 Assertions.assertEquals(CiString.of(\u0026#34;String\u0026#34;), CiString.of(\u0026#34;sTRING\u0026#34;)); 10 Assertions.assertNotEquals(null, CiString.of(\u0026#34;\u0026#34;)); 11 } 12 @Test 13 public void testHashCode_caseInsensitive() { 14 CiString lowerCase = CiString.of(\u0026#34;sTriNg\u0026#34;); 15 CiString upperCase = CiString.of(\u0026#34;StRING\u0026#34;); 16 Assertions.assertEquals(lowerCase.hashCode(), upperCase.hashCode()); 17 } 18 @Test 19 public void of_whenNullString_thenException() { 20 NullPointerException nullPointerException = Assertions 21 .assertThrows(NullPointerException.class, () -\u0026gt; CiString.of(null)); 22 23 Assertions.assertEquals(\u0026#34;stringVal is marked non-null but is null\u0026#34;, nullPointerException.getMessage()); 24 } 25 @Test 26 public void toStringTest() { 27 Assertions.assertEquals(\u0026#34;test\u0026#34;, CiString.of(\u0026#34;test\u0026#34;).toString()); 28 } 29} Other Solutions: Baeldung In this article, you can find a description of the problem we are discussing. The article also proposes several solutions to the problem, including the previously mentioned Solution 1. In addition to that, the article suggests using Apache's CaseInsensitiveMap or Spring's LinkedCaseInsensitiveMap as alternative solutions. However, it is important to note that both of these solutions are based on lowercasing the keys, which may not be the desired behavior in certain scenarios.\nI'm active on Twitter and LinkedIn, and I'd love it if you could give me a follow. You can find me on Twitter at @mare_milenkovic and on LinkedIn at mare-milenkovic.\n","link":"https://www.professionaldev.pro/post/java/case_insensitive_string_hashmap/","section":"post","tags":["java","hashMap"],"title":"How To Use Case Insensitive String in Hash Map"},{"body":"","link":"https://www.professionaldev.pro/tags/java/","section":"tags","tags":null,"title":"java"},{"body":"","link":"https://www.professionaldev.pro/categories/java/","section":"categories","tags":null,"title":"java"},{"body":"","link":"https://www.professionaldev.pro/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"https://www.professionaldev.pro/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://www.professionaldev.pro/tags/peformance/","section":"tags","tags":null,"title":"peformance"},{"body":"","link":"https://www.professionaldev.pro/categories/peformance/","section":"categories","tags":null,"title":"peformance"},{"body":"Introduction Modern hardware is very good at predicting the next instructions to be executed. This kind of prediction allows CPUs to do more work in less time. One of the strategies that hardware relies on is data locality. This means that when CPU requests data from main memory, it not only retrieves the requested data, but the hardware also retrieves the data that is stored in proximity to the requested data.\nOn the software side, the Java compiler is heavily optimized to assist the hardware in these optimizations. Despite these optimizations, there are cases where none of them can help us. If we as programmers don't address this issue, it can lead to degraded application performance.\nBefore I continue, let me tell you this:\nDon't optimize your application prematurely!\nIf you don't have performance issues with your application, you don't need to optimize. However, it pays to know what can affect the performance of your application and how you can be more careful and write better performing code.\nWhat Is Memory Churn? Memory churn refers to the continuous and repetitive process of creating, deleting, and reallocating memory in a computer system. It is the rate at which memory is allocated and deallocated over a certain period of time, usually measured in cycles or seconds.\nMemory churn can have an impact on the overall performance of a computer system. When memory is constantly allocated and deallocated, it can lead to fragmentation of the memory space, which can result in slower performance and increased resource usage.\nOne common example of memory churn is in software applications that allocate and deallocate memory frequently, such as video games or web browsers. These applications can cause significant memory churn, leading to slower performance and increased resource usage over time. Overall, minimizing memory churn is important for maintaining optimal performance and resource usage in computer systems. This can be achieved through various strategies, such as efficient memory management and reducing unnecessary memory allocations and deallocations.\nThe JVM runs garbage collection periodically, either when it can, because the program threads are waiting for some external event, or when it needs to, because it's run out of memory for creating new objects. Despite the automatic nature of the process, it's important to understand that it's going on, because it can be a significant part of the overhead of Java programs.\nExample of Memory Churn One common example of memory churn that can occur in applications is when data is stored in a hash map with a composite key consisting of two combined strings. Let me show you an example:\nLet's say that we want to fetch a person data from in-memory Person repository. Contents of the PersonRepository and the Person class are defined as following:\n1@Value 2public class Person { 3 String firstName; 4 String lastName; 5 int age; 6} 7 8public class PersonRepository { 9 10 Map\u0026lt;String, Person\u0026gt; personNameMap = new HashMap\u0026lt;\u0026gt;(); 11 12 public Person findPersonByFullName(String firstName, String lastName) { 13 return personNameMap.get(firstName + lastName); 14 } 15 /*...*/ 16} Note: In the examples in this article, I used Lombok annotations to reduce the need for writing boilerplate code. You can find more details about it on the following link.\nOn first look, this code looks good to most of the developers. But, there is one performance issue that can arise if there is a massive load on the findPersonByFullName method. To understand the problem, let's check how the + operator for String concatenation works in Java. In Java 8, this concatenation is implemented using StringBuilder class. So the code for string concatenation would be implemented as follows:\n1public class Person { 2 /*...*/ 3 public Person findPersonByFullName(String firstName, String lastName) { 4 return personNameMap1.get(new StringBuilder().append(firstName).append(lastName).toString()); 5 } 6} 7 8public class StringBuilder extends AbstractStringBuilder { 9 /*...*/ 10 11 /** 12 * Constructs a string builder with no characters in it and an 13 * initial capacity of 16 characters. 14 */ 15 @IntrinsicCandidate 16 public StringBuilder() { 17 super(16); 18 } 19 /*...*/ 20} 21 22public class AbstractStringBuilder { 23 /*...*/ 24 /** 25 * Creates an AbstractStringBuilder of the specified capacity. 26 */ 27 AbstractStringBuilder(int capacity) { 28 if (COMPACT_STRINGS) { 29 value = new byte[capacity]; 30 coder = LATIN1; 31 } else { 32 value = StringUTF16.newBytesFor(capacity); 33 coder = UTF16; 34 } 35 } 36 /*...*/ 37} 38 39public class String /*...*/ { 40 /*...*/ 41 /* 42 * Package private constructor. Trailing Void argument is there for 43 * disambiguating it against other (public) constructors. 44 */ 45 String(AbstractStringBuilder asb, Void sig) { 46 byte[] val = asb.getValue(); 47 int length = asb.length(); 48 if (asb.isLatin1()) { 49 this.coder = LATIN1; 50 this.value = Arrays.copyOfRange(val, 0, length); 51 } else { 52 // only try to compress val if some characters were deleted. 53 if (COMPACT_STRINGS \u0026amp;\u0026amp; asb.maybeLatin1) { 54 byte[] buf = StringUTF16.compress(val, 0, length); 55 if (buf != null) { 56 this.coder = LATIN1; 57 this.value = buf; 58 return; 59 } 60 } 61 this.coder = UTF16; 62 this.value = Arrays.copyOfRange(val, 0, length \u0026lt;\u0026lt; 1); 63 } 64 } 65 /*...*/ 66} By examining the StringBuilder parameterless constructor, it becomes apparent that its character array is initialized with a default size of 16. If the concatenation's result exceeds this limit, a new array must be created and initialized. And all the data must be copied over to the new array. Finally, when the toString method is called, the array is once again copied to create the resulting string.\nThe + operator has much better implementation in Java 17. StringConcatFactory.makeConcatWithConstants method is used for strings concatenation. It further calls the method StringConcatHelper.simpleConcat for the special case of two strings concatenation. This method is the fastest implementation for the String concatenation that I have seen till now in Java. It is optimized to create just one character array for all the concatenations. And not only that, it uses the same character array to create a new instance of String class. This can be done only in jdk code, since the constructor for String class that accepts character array is package private. Here is the content of simpleConcat method.\n1/** JDK 18 code 2 * 3 * 4 * Perform a simple concatenation between two objects. Added for startup 5 * performance, but also demonstrates the code that would be emitted by 6 * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy} 7 * for two Object arguments. 8 * 9 * @param first first argument 10 * @param second second argument 11 * @return String resulting string 12 */ 13@ForceInline 14static String simpleConcat(Object first, Object second) { 15 String s1 = stringOf(first); 16 String s2 = stringOf(second); 17 if (s1.isEmpty()) { 18 // newly created string required, see JLS 15.18.1 19 return new String(s2); 20 } 21 if (s2.isEmpty()) { 22 // newly created string required, see JLS 15.18.1 23 return new String(s1); 24 } 25 // start \u0026#34;mixing\u0026#34; in length and coder or arguments, order is not 26 // important 27 long indexCoder = mix(initialCoder(), s1); 28 indexCoder = mix(indexCoder, s2); 29 byte[] buf = newArray(indexCoder); 30 // prepend each argument in reverse order, since we prepending 31 // from the end of the byte array 32 indexCoder = prepend(indexCoder, buf, s2); 33 indexCoder = prepend(indexCoder, buf, s1); 34 return newString(buf, indexCoder); 35 } From the above description, it can be inferred that the example code generates a huge number of objects (specially in java 8 example). Garbage collector needs to clean up those objects at some point in time. The greater the number of memory allocations made by an application, the more the garbage collector is required to work in order to clean them up. Furthermore, these objects happen to be arrays. It means that objects are memory heavy. This can lead to additional strain on the garbage collector. As a result, memory churn may occur.\nHow Can We Fix It? The solution would be to reduce the number of allocations. For example, we can consider creating a pool of objects that can be reused (something like thread pools). The proposed solution wouldn't work on this example, because we don't know what instances of the String object will be created.\nWhat Can We Do Then? If we must allocate memory, then we should check if we can perform smaller memory allocations. We can create a new class that will contain references to existing strings. The class must implement equals and hashCode methods. Requested behaviour will be the same, but the amount of allocated memory will be significantly smaller. We can call this class PersonPk and implement it as follows:\n1@Value 2public class PersonPk { 3 private final String firstName; 4 private final String lastName; 5} By creating new objects with references to existing strings, we can reduce the burden on the garbage collector. This should improve performance.\nIn the end, I compared the performance of both methods and recorded the following results:\n1Java 8 2Benchmark (nameLength) Mode Cnt Score Error Units 3MemoryChurnBench.getFromRepoNewObject 5 thrpt 5 6366.565 ± 342.554 ops/s 4MemoryChurnBench.getFromRepoNewObject 10 thrpt 5 6365.775 ± 331.102 ops/s 5MemoryChurnBench.getFromRepoNewObject 100 thrpt 5 6388.885 ± 44.873 ops/s 6MemoryChurnBench.getFromRepoNewObject 1000 thrpt 5 6246.701 ± 531.240 ops/s 7MemoryChurnBench.getFromRepoNewObject 10000 thrpt 5 6564.168 ± 1421.583 ops/s 8MemoryChurnBench.getFromRepoStringConcat 5 thrpt 5 3151.173 ± 39.861 ops/s 9MemoryChurnBench.getFromRepoStringConcat 10 thrpt 5 2531.838 ± 89.890 ops/s 10MemoryChurnBench.getFromRepoStringConcat 100 thrpt 5 391.318 ± 0.190 ops/s 11MemoryChurnBench.getFromRepoStringConcat 1000 thrpt 5 35.975 ± 0.039 ops/s 12MemoryChurnBench.getFromRepoStringConcat 10000 thrpt 5 3.762 ± 0.001 ops/s 13 14Java 17 15Benchmark (nameLength) Mode Cnt Score Error Units 16MemoryChurnBench.getFromRepoNewObject 5 thrpt 5 10286.933 ± 709.515 ops/s 17MemoryChurnBench.getFromRepoNewObject 10 thrpt 5 10687.213 ± 167.468 ops/s 18MemoryChurnBench.getFromRepoNewObject 100 thrpt 5 10675.250 ± 1194.855 ops/s 19MemoryChurnBench.getFromRepoNewObject 1000 thrpt 5 11001.058 ± 1460.443 ops/s 20MemoryChurnBench.getFromRepoNewObject 10000 thrpt 5 10464.001 ± 80.074 ops/s 21MemoryChurnBench.getFromRepoStringConcat 5 thrpt 5 3036.421 ± 524.678 ops/s 22MemoryChurnBench.getFromRepoStringConcat 10 thrpt 5 3133.770 ± 401.871 ops/s 23MemoryChurnBench.getFromRepoStringConcat 100 thrpt 5 2291.642 ± 122.767 ops/s 24MemoryChurnBench.getFromRepoStringConcat 1000 thrpt 5 238.308 ± 1.260 ops/s 25MemoryChurnBench.getFromRepoStringConcat 10000 thrpt 5 28.638 ± 0.278 ops/s Conclusion From the results above, we can draw the following conclusions:\nThe bigger the strings that are used for concatenation, the bigger the memory churn is. Java 17 has an order of magnitude better performance for string concatenation compared to java 8. Optimized version of code, without string concatenation, performs much better than string concatenation. This statement is true for all versions of Java. Java 17 has much performs better when it comes to garbage collection. For more stuff like this, you can follow me on Twitter, LinkedIn, or visit my website.\nAppendix: Java Code Used for Benchmarking At the end, here is the code that I used to perform benchmarks:\n1@Fork(warmups = 0, value = 1) 2@BenchmarkMode(Mode.Throughput) 3@OutputTimeUnit(TimeUnit.SECONDS) 4@Measurement(time = 10, iterations = 5) 5@Warmup(iterations = 5, time = 1) 6public class MemoryChurnBench { 7 private static final int TOTAL_NO_ITEMS = 10_000; 8 9 @State(Scope.Benchmark) 10 public static class InputParams { 11 PersonRepository personRepository = new PersonRepository(); 12 @Param({\u0026#34;5\u0026#34;, \u0026#34;10\u0026#34;, \u0026#34;100\u0026#34;, \u0026#34;1000\u0026#34;, \u0026#34;10000\u0026#34;}) 13 private int nameLength; 14 15 List\u0026lt;Pair\u0026lt;String, String\u0026gt;\u0026gt; searchPersonNamesList; 16 17 public InputParams() { 18 } 19 20 @Setup(Level.Trial) 21 public void createRandomList() { 22 searchPersonNamesList = new ArrayList\u0026lt;\u0026gt;(TOTAL_NO_ITEMS); 23 Set\u0026lt;String\u0026gt; generated = new HashSet\u0026lt;\u0026gt;(); 24 for (int i = 0; i \u0026lt; TOTAL_NO_ITEMS; i++) { 25 String firstName = getUniqueFirstName(generated); 26 String lastName = getUniqueLastName(generated); 27 searchPersonNamesList.add(Pair.of(firstName, lastName)); 28 } 29 } 30 31 private String getUniqueLastName(Set\u0026lt;String\u0026gt; generated) { 32 String firstName; 33 do { 34 firstName = getLastName(nameLength); 35 } 36 while (generated.contains(firstName)); 37 return firstName; 38 } 39 40 private String getUniqueFirstName(Set\u0026lt;String\u0026gt; generated) { 41 String firstName; 42 do { 43 firstName = getFirstName(nameLength); 44 } 45 while (generated.contains(firstName)); 46 return firstName; 47 } 48 49 public String getFirstName(int i) { 50 return getString(\u0026#34;F:\u0026#34;, i); 51 } 52 53 private static String getString(String prefix, int length) { 54 return prefix + RandomStringUtils.random(length, true, true); 55 } 56 57 public String getLastName(int i) { 58 return getString(\u0026#34;L:\u0026#34;, i); 59 } 60 61 public void setNameLength(int nameLength) { 62 this.nameLength = nameLength; 63 } 64 } 65 66 @Benchmark 67 public void getFromRepoStringConcat(InputParams params, Blackhole b) { 68 for (int i = 0; i \u0026lt; TOTAL_NO_ITEMS; i++) { 69 Pair\u0026lt;String, String\u0026gt; personFullName = params 70 .searchPersonNamesList 71 .get(i); 72 Person repositoryPerson = params 73 .personRepository 74 .findPerson1(personFullName.left(), personFullName.right()); 75 b.consume(repositoryPerson); 76 } 77 } 78 79 @Benchmark 80 public void getFromRepoNewObject(InputParams params, Blackhole b) { 81 for (int i = 0; i \u0026lt; TOTAL_NO_ITEMS; i++) { 82 Pair\u0026lt;String, String\u0026gt; personFullName = params 83 .searchPersonNamesList 84 .get(i); 85 Person repositoryPerson = params 86 .personRepository 87 .findPerson2(personFullName.left(), personFullName.right()); 88 b.consume(repositoryPerson); 89 } 90 } 91} ","link":"https://www.professionaldev.pro/post/java/memory_churn/","section":"post","tags":["java","peformance"],"title":"What Is Memory Churn and How to Avoid It in Java"},{"body":"Extracting archive files without controlling resource consumption is security-sensitive and can lead to denial of service.\nOur code executes on servers, but you should know that servers have limits. Based on this, check how many hardware resources your code can consume. Resources are CPU, RAM, disk, network... Understand those limits and, based on those limits, put thresholds in your code.\nHere are some important thresholds you should put in a code when extracting a zip archive.\n1. Limit the size of an extracted archive This is the most basic and critical threshold you should introduce when extracting a zip archive.\nHow to limit extracted size? You can check the size after you extract the archive, but this can be too late. If the extracted content is too big, it can drain your server resources.\nYou should include a size threshold check in the extraction process. Each time you extract and get some bytes from an archive, compare the total extracted size with the threshold.\nZip archives also have metadata. In metadata, you can find each entry's file size. But, as another application wrote metadata, this information doesn't need to be correct.\n2. Limit the number of entries in an archive Each file system has some limitations in terms of the number of files and directories that can handle in a directory/partition/hard drive... Those limits are usually huge numbers. Even so, this is a limited resource. In the Sonar article there is the following statement:\nToo many entries in an archive, can lead to inodes exhaustion of the system.\nInodes are indexes that point to the actual location of a file on a disk. If you have too many small files on the file system, it can drain out available inodes. Consequently, your system cannot store new files.\nInodes are used on the linux/unix file systems, but a similar limit also exists for windows. Source: stackoverflow.\n3. Protect yourself against zip bomb Successful Zip Bomb attacks occur when an application expands untrusted archive files without controlling the size of the expanded data, which can lead to denial of service. Source: Sonar article\nA Zip bomb is usually a malicious archive file of a few kilobytes with extracted content measured in gigabytes. To achieve this extreme compression ratio, attackers will compress irrelevant data (e.g., a long string of repeated bytes).\nYou can have a total archive file size threshold, but you should always strive to fail fast. The compression ratio can give you an idea of whether the data in the archive is relevant. The data compression ratio for most legit archives is 1 to 3. And in the example from the sonar article threshold is 10, which should be a good value.\nHere you can find example zip bomb files.\n4. Forbid folders inside an archive. Check with your business people if you can forbid folders inside an archive. In return, you will avoid recursion in the code.\nWhy is this important? If you don't implement recursion properly, it can break your application in many ways. It will also add extra complexity to your code, which can lead to bugs. It will take more work to understand the logic of the code. it will be harder to maintain that code. In a server environment, using recursion is dangerous! If you need to implement recursion, please be extra careful!\n5. Don't extract archives inside an archive This will also create the same problem as with extracting folder content. It is better to go with one of the following options:\nTreat archive files in the archive as all other files - don't extract them. Check with the business if you can forbid the archive files inside an archive. You can ask this question because compressing an already compressed archive will not lead to a smaller file. You can forbid archive entries by checking entry extension and mime type during the extraction process. 6. Don't rely only on archive entry metadata Archives contain metadata that you can read during the extraction process. Compressing application wrote this data in an archive during the compression process.\nThe problem with this is that if you rely only on those properties, you need to trust a compressing application that is not in your control. Hackers can create fake metadata and crush your application.\nBe careful when using zip archive metadata. Always ask yourself how attackers can abuse it to hack your extraction algorithm.\n","link":"https://www.professionaldev.pro/post/java/extract_zip_stream_best_practices/","section":"post","tags":["zip","java"],"title":"Best Practices That You Should Follow When Extracting Zip Archive in Java"},{"body":"","link":"https://www.professionaldev.pro/tags/zip/","section":"tags","tags":null,"title":"zip"},{"body":"","link":"https://www.professionaldev.pro/tags/carrier/","section":"tags","tags":null,"title":"carrier"},{"body":"","link":"https://www.professionaldev.pro/categories/carrier/","section":"categories","tags":null,"title":"carrier"},{"body":"Here are several reasons: We work in teams.\nThe better we know how to communicate with people in a team, the better we will be. Remember, your whole company is one big team. We use programming languages to communicate between each other.\nHardware doesn't need a programming language to process our intentions. All languages compile at the end in machine code. Programming languages are here to help us communicate ideas. The cleaner(more readable) code you write, the more understandable it will be to other developers. This leads to more maintainable software. Soft skills usually apply to your private life, making you a better person. The root of the word Software is Soft :o\nThese days, teams create great and successful products, not one person. Learn how to be a team player. Where can you start? Here are several subjects that are very important: Learn how to listen. Learn active listening. This is one of the most essential skills to learn. And it applies to more than work. You can (and should) use this skill in your private life. Learn about leadership. Everyone is a leader in some sense. Google \u0026quot;Simon Sinek\u0026quot; - he is an excellent resource for this subject. Learn about ownership. The best workers are those who own the work assigned to their team. Learn about empathy. To understand how people around you feel like. Learn about assertive communication! You probably know about this. If not, ask your HR! They just love this subject. ;) ","link":"https://www.professionaldev.pro/post/soft_skills/","section":"post","tags":["carrier"],"title":"Why Should You, as a Software Developer, Learn Soft Skills?"},{"body":"","link":"https://www.professionaldev.pro/tags/concurrent-tests/","section":"tags","tags":null,"title":"concurrent tests"},{"body":"","link":"https://www.professionaldev.pro/tags/java-testing/","section":"tags","tags":null,"title":"java testing"},{"body":"","link":"https://www.professionaldev.pro/tags/junit-5/","section":"tags","tags":null,"title":"junit 5"},{"body":"","link":"https://www.professionaldev.pro/tags/junit-5-testing/","section":"tags","tags":null,"title":"junit 5 testing"},{"body":"","link":"https://www.professionaldev.pro/tags/junit-testing/","section":"tags","tags":null,"title":"junit testing"},{"body":"","link":"https://www.professionaldev.pro/tags/maven/","section":"tags","tags":null,"title":"maven"},{"body":"","link":"https://www.professionaldev.pro/tags/multithreaded-tests-in-java/","section":"tags","tags":null,"title":"multithreaded tests in java"},{"body":"","link":"https://www.professionaldev.pro/tags/parallel-tests/","section":"tags","tags":null,"title":"parallel tests"},{"body":"Introduction We need fast-build pipelines. This is because we need fast feedback from our pipeline in order to be more productive. If something is wrong with our code, then we want our pipeline to fail fast. To accomplish that, you may decide to allow parallel test execution for tests in your project. This post describes how to do that with Maven and Junit 5.\nGetting Started With Junit 5 and Maven To get started with Junit 5, you need to import the following dependency into the project:\n1 2\u0026lt;dependency\u0026gt; 3 \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; 4 \u0026lt;artifactId\u0026gt;junit-jupiter-engine\u0026lt;/artifactId\u0026gt; 5 \u0026lt;version\u0026gt;5.9.0\u0026lt;/version\u0026gt; 6 \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; 7\u0026lt;/dependency\u0026gt; At the time of writing this article, version 5.9.0 is the newest. You should check maven repository for a new version. Notice, that we imported the library in test scope as there is no need for this library to be in production code because we only use it for running tests.\nRunning Tests in Parallel Maven offers you two ways for running tests in parallel:\nBy starting multiple JVM instances By using multiple threads in the same JVM instance 1. By Using the Parallel Parameter The setup for parallel test execution is straightforward. Include the following parameter:\n1 2\u0026lt;forkCount\u0026gt;2\u0026lt;/forkCount\u0026gt; It must have a value greater than 1 to enable parallel execution. It is important to know that parallel execution is achieved by starting multiple JVM child processes. This has multiple consequences, and it can affect your decision to use this method. Maven starts multiple JVM instances, and this means that it consumes more memory. Each thread has its own memory space. But it accomplishes a greater level of test independence, as processes cannot share data. You can use this method when you need to use an in-memory database for your unit tests.\nThe parameter forkCount has a fixed positive integer value which represents the number of forks. Of course, it is usual that multiple developers work on the same project, and we don't know how many cores other developers will have on their machines. To better use hardware, it would be great if we can set this parameter to create a number of forks that depends on the number of cores on CPU. Maven supports this, and you can configure it in the following way:\n1 2\u0026lt;forkCount\u0026gt;1C\u0026lt;/forkCount\u0026gt; This configuration instructs Maven to create one fork for each core. If your CPU has two virtual threads per core, you can also enter 2Cto use most CPU resources. Or if you don't want to use 100% of your CPU, you can enter 0.5C which will instruct Maven to create forks for the half of CPU cores.\n2. By Setting up Junit Multi-Thread Execution Maven uses plugins for everything. This is also the case for running project tests. To run project tests, Maven uses the Surefire plugin. Unfortunately, it uses the old version of the plugin by default, which doesn't support Junit5 test execution. So, we need to import a newer version of this plugin to Maven. To include a newer version of this plugin, we need to configure Maven. We can do this by adding the following XML to the pom.xml:\n1 2\u0026lt;build\u0026gt; 3 \u0026lt;pluginManagement\u0026gt; 4 \u0026lt;plugins\u0026gt; 5 \u0026lt;plugin\u0026gt; 6 \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; 7 \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; 8 \u0026lt;version\u0026gt;3.0.0-M7\u0026lt;/version\u0026gt; 9 \u0026lt;configuration\u0026gt; 10 We will add configuration here 11 \u0026lt;/configuration\u0026gt; 12 \u0026lt;/plugin\u0026gt; 13 \u0026lt;/plugins\u0026gt; 14 \u0026lt;/pluginManagement\u0026gt; 15\u0026lt;/build\u0026gt; The XML is quite self-descriptive. We add new plugin that is in build-\u0026gt;pluginManagement-\u0026gt;plugins section of Maven pom.xml. We import the newest version of the surefire plugin at the time of writing this article. You can check this url for a newer version.\nNow, when we have a newer version of the surefire plugin loaded, we can continue to configure Maven for multithreaded test execution.\nIn the official Maven documentation, to achieve this, you need to use parallel, threadCount and useUnlimitedThreads parameters. I tried all these parameters, but nothing worked with Junit 5. By checking official documentation for Maven Surefire and Junit 5 we can conclude that Junit 5 supports a new multithreaded execution model (which is still in the preview phase). So, to configure multithreaded execution, we need to configure Junit5 as well. We can do this by setting up properties in the Maven configuration.\n1 2\u0026lt;configuration\u0026gt; 3 \u0026lt;properties\u0026gt; 4 \u0026lt;configurationParameters\u0026gt; 5 junit.jupiter.execution.parallel.enabled=true 6 ... 7 \u0026lt;/configurationParameters\u0026gt; 8 \u0026lt;/properties\u0026gt; 9\u0026lt;/configuration\u0026gt; Another option is to create junit-platform.properties file. Put it into test/resources folder, and put all the properties in that file instead of pom.xml.\nIt is enough to set ``junit.jupiter.execution.parallel.enabled=trueto allow parallel test execution. But, if you try running the test after setting up this parameter value totrue``` it will surprise you to see that tests are still running sequentially. The reason for this is that there are 2 strategies in which you can allow parallel execution in tests.\nJunit can assume that all tests are sequential, and only ones that are annotated with @Execution(CONCURRENT) will be executed in parallel. You can use this annotation on a class or test method to enable parallel execution. You can set parameter junit.jupiter.execution.parallel.mode.default = concurrent. Here, all tests will run in parallel by default except ones annotated with ExecutionMode.SAME_THREAD. How Many Threads Junit Will Use for Parallel Execution? This is also configurable property junit.jupiter.execution.parallel.config.strategy=dynamic and it also has default value dynamic. Strategy can be also fixed or custom. If we set up fixed value for this property, then we also need to set up the value for the junit.jupiter.execution.parallel.config.fixed.parallelism=\u0026lt;positive integer\u0026gt;. This is not a scalable solution, and we should use dynamic value to better utilize the hardware.\ndynamic property also has a connected property that influences how many threads JUnit will create. junit.jupiter.execution.parallel.config.dynamic.factor=\u0026lt;positive decimal number\u0026gt;. Factor to multiply by the number of processors/cores to determine the desired parallelism for the dynamic configuration strategy.\nConclusion Parallel test execution can speed up your build, but you must be careful when enabling it as it will not always provide you with better performance. This is because the tests may use the same resource, and they can wait for each other to access it. Because of that, it is always a good idea to test and check everything.\nAnother more significant problem with parallel tests is if the tests are not independent, there can be flaky tests. They are very hard to debug and identify.\nIf you liked this post, you can follow me on Twitter or LinkedIn for more content.\nResources Maven documentation\nJunit guide\nJUnit5 Parallel Execution of tests\n","link":"https://www.professionaldev.pro/post/java/java_multithread_junit5/","section":"post","tags":["java","maven","junit 5","testing","parallel tests","concurrent tests","junit testing","java testing","junit 5 testing","multithreaded tests in java"],"title":"Setting up Junit 5 Parallel Test Execution With Maven"},{"body":"","link":"https://www.professionaldev.pro/tags/testing/","section":"tags","tags":null,"title":"testing"},{"body":"","link":"https://www.professionaldev.pro/categories/testing/","section":"categories","tags":null,"title":"testing"},{"body":" Currently, I work as Senior Java Developer \u0026amp; Tech Lead at Badin Soft. With more than 8 years of professional experience as a Backend Developer and experience with software development since 2007. Worked with Java Web Services and relational databases on different fintech products. My focus is on helping professional Java developers to optimize their work and solve problems using best practices, new technologies and methodologies by writing clean, secure and performant code in agile environment, so they can build great products, solve complex problems, and become efficient and successful developers.\n","link":"https://www.professionaldev.pro/about/","section":"","tags":null,"title":"About Me"},{"body":"","link":"https://www.professionaldev.pro/tags/developers/","section":"tags","tags":null,"title":"developers"},{"body":"","link":"https://www.professionaldev.pro/tags/developers-biggest-problem/","section":"tags","tags":null,"title":"developers biggest problem"},{"body":"I have attended the workshop that is organized by the ITKonekt. The workshop was about efficient coding practices for best performance in Java. Java Champion Victor Rentea did a great job explaining all java internals, tools, hibernate, threads, collections, garbage collections, and much more. It was very enjoyable to learn from him, and I decided to ask him the question:\nWhat is the biggest problem that professional Java developers are facing today?\nHis initial answer was: \u0026quot;Not writing enough Java. They write Kubernetes scripts, dev-ops scripts, python scripts…\u0026quot;\nMy understanding of this is that those people are very experienced developers. He also mentioned that this is what his colleagues are working on currently. But if you are just starting your career, he has advice for you:\nIf you are starting a career, then you should learn the language and frameworks that you are using. You should master the language and frameworks. This is the first challenge. Don't be disgusted by the front-end technologies, try to be full stack after you master Java. This is after you are comfortable with Java. Go a bit full stack, not \u0026quot;full full\u0026quot; stack, but \u0026quot;just a bit\u0026quot; full stack. Try to learn more about what surrounds you. Learn some other language. Kotlin is a good one. Learn dev ops. Try to learn a bit of everything. He also gave me this advice:\nAs long as you are surrounded by people smarter than you, you are good. And as long as you love to work with your team, you are good. Doesn't matter project or technology, it can be a terrible legacy system. If you have super cool surroundings, and you keep learning, and you keep having fun, it's perfect.\nIf you liked this post, you can follow me on Twitter, or LinkedIn.\nVictor is a great trainer and one of the best presenters. You can find him at the following links:\nWebsite victorrentea.ro you can find a blog, recorded talks, plus other goodies. Bucharest-software-craftsmanship-community (3000+ developers). Twitter http://www.linkedin.com/in/victor-rentea-trainer[LinkedIn], https://fb.me/VictorRentea.ro[Facebook]. Victor's YouTube Channel - here you can find more recorded and live content, including coding katas, recordings of past meetups, and more. ","link":"https://www.professionaldev.pro/post/java/victor_biggest_problem_for_java_devs/","section":"post","tags":["java","developers","developers biggest problem"],"title":"I Asked a Java Champion: What Is the Biggest Problem That Professional Java Developers Are Facing Today?"},{"body":"Based on my previous experience, I created a list of 10 mistakes that developers made, preventing them from being a great developer. Here is the list:\n1. Not writing unit tests Developers that don’t write unit tests produce more bugs from the code they write and maintain. That leads to unstable products and client dissatisfaction.\nIf you are not familiar with writing unit tests, there are some resources to get started with:\nhttps://www.vogella.com/tutorials/Mockito/article.html https://www.baeldung.com/mockito-series https://www.softwaretestinghelp.com/mockito-tutorial/ 2. Not manually testing code Even if you completely cover your code with unit tests, there is still a chance that you missed something out. It happens in practice that some error pushes through.\nIt is always good practice to manually test code before pushing it for code review. By doing this, you will look at your solution from the client’s perspective. And not only that you can detect bugs, but you can also identify design problems in the development stage.\n3. Having the mindset “This will never happen” Developers often make mistakes when they write new code by thinking that certain scenarios in code will never happen. Eventually, it turns out that they are wrong. In those situations, applications can behave unpredictably and it can lead to bugs. Handle every scenario that code can go into.\nDefensive programming techniques will help you in that. If you are not familiar with defensive programming, you can check the following Pluralsight course: https://www.pluralsight.com/courses/defensive-programming-java\n4. Not asking for feedback and not giving feedback To improve yourself, regularly ask for feedback. You can as for feedback when you finish a ticket, or after finishing a project, or when you do a presentation… There is no bad time to ask for feedback.\nGive feedback to your colleagues. And not by telling them they are great even if you think they are not so good. Tell them areas where they can improve themselves. If the feedback is honest, they will appreciate you more.\n5. Not checking the performance of code Often, developers write their code, but they don’t check for performance. When code goes to production, it creates various problems. Poor performance can even crush the server.\n6. Writing long procedural code It is very easy to write long methods with a bunch of logic. By doing this, programmers put the same logic in many places. Projects with a lot of small methods have much greater code reusability and are much easier to maintain.\n7. Not being familiar with the tools Tools are extensions of your hands. The better you know them, the more productive you will be. You should be very familiar with the IDE you use.\nLearn shortcuts, they will make you much more productive. Try learning one shortcut to a day and create your personal cheat sheet.\nResearch plugins, usually you will find a plugin that will help you be even more productive. Plugins that will help you write better code in Intellij Idea are Sonar Lint, Spot bugs, and Code Metrics.\n8. Ignoring problems in code Developers that are working on the most successful products are changing the code all the time. Don’t be afraid to refactor code. If your code is unit tested, then there is a low probability of introducing a regression.\nBut, don’t stop there. Developers often ignore problematic code that is not part of their ticket. As a developer, you are responsible to maintain an application and keep it in good shape. Because of that, fix all problems that you find.\nThe best way to proceed with fixing the problem is to create a ticket and work on it with your team. The following story emphasizes why it is important not to ignore problems in code: https://blog.codinghorror.com/the-broken-window-theory/.\n9. Coding by accident Developers should NEVER do a code modification and push that code in production without understanding the consequences of it. Code can produce correct results for given test values. However, there can be scenarios where it can produce unpredicted results and create serious problems.\nCoding by accident often happens when developers use features from libraries that don’t completely understand. It can also happen when the developer solves the problem without understanding the solution.\n10. Not asking for help Developers are not very communicative people. They like to solve problems by themselves. The era where one developer creates a complete solution from start to end is over.\nDeveloping software is a team activity. When you encounter a problem during programming, try to solve it by yourself. But don’t waste too much time if you can’t figure out the solution. There is a high probability that some of your colleagues already encounter the same problem and know a solution.\nIf it is not the case, then you will get help and the team will understand that the problem is complex and that you need time to solve it. Involving more people will help you resolve complex problems faster. Developers that don’t ask for help, usually spend too much time on a ticket.\nHelp others when you see they have problems with their ticket. As a result, the team will be more productive and people will like you more.\nIf you like this content, you can follow me on Twitter or LinkedIn.\n","link":"https://www.professionaldev.pro/post/java/teen_mistakes/","section":"post","tags":["java","java developers","mistakes","java mistakes","developers mistakes","successful developers"],"title":"10 Mistakes That Java Developers Make That Prevent Them From Being Successful Developers"},{"body":"","link":"https://www.professionaldev.pro/tags/developers-mistakes/","section":"tags","tags":null,"title":"developers mistakes"},{"body":"","link":"https://www.professionaldev.pro/tags/java-developers/","section":"tags","tags":null,"title":"java developers"},{"body":"","link":"https://www.professionaldev.pro/tags/java-mistakes/","section":"tags","tags":null,"title":"java mistakes"},{"body":"","link":"https://www.professionaldev.pro/tags/mistakes/","section":"tags","tags":null,"title":"mistakes"},{"body":"","link":"https://www.professionaldev.pro/tags/successful-developers/","section":"tags","tags":null,"title":"successful developers"},{"body":"","link":"https://www.professionaldev.pro/tags/functional-programming/","section":"tags","tags":null,"title":"functional programming"},{"body":"","link":"https://www.professionaldev.pro/categories/functional-programming/","section":"categories","tags":null,"title":"functional programming"},{"body":"","link":"https://www.professionaldev.pro/tags/getting-started-with-functional-programming-in-java/","section":"tags","tags":null,"title":"getting started with functional programming in java"},{"body":"As a Java developer, I always look for ways to improve my coding skills. I heard about functional programming (FP) back when I was a student. Then, FP was not very popular and most developers considered code written using FP to be slow.\nTime has changed and today FP is very popular. Some developers are considering it to be the future of how developers write code.\nFP is the most useful concept that I learned in the last several years. It helped me to become a better developer. I started writing cleaner code with fewer bugs.\nHere are the immediate benefits I got from FP: I sharpen my skills related to using Java Streams. It is much easier for me to work with Streams when I understand FP concepts. My functions that follow FP concepts are easy to understand and maintain. There is no risk to using them in a concurrent environment. The reusability of those functions is much greater. If you are not a fan of “if” and “for” statements, then you will like FP. It can help you write more understandable code that doesn’t include those statements. I can do more with fewer lines of code. The FP is a declarative paradigm. With FP you describe what you want, rather than how to get it. This means that the code is more readable, reusable, and it is easier to maintain. So, how I started with functional programming? We can find a ton of material on the internet related to FP. I usually like to watch video material when I want to learn about a new subject.\nI attended an online presentation hold by Venkat Subramaniam. It was a great and inspiring presentation. The good news is that you can watch it on the following link: Functional Programming with Java 8.\nAfter that presentation, I gained an interest in FP, so I decided to study more about FP. I watched the Pluralsight course Functional Programming: The Big Picture. This course helped me understand the big picture of FP and why it matters.\nThe next natural step was to check if there is a course that's subject is related to implementing FP concepts in Java. I found the course Applying Functional Programming Techniques in Java. It is a great course. It helped me learn, understand, and apply new FP concepts in Java.\nAfter watching those courses, I wanted to know more about Monads. They are very important in FP. Following two videos helped me understand Monads: Brian Beckman: Don't fear the Monad and What the ƒ is a Monad?.\nLearn from Haskell I started learning Haskell. At the end of Venkat Subramaniam's presentation, I asked him if learning Haskell will help me better understand FP concepts. The answer was something like: “Not only Haskell helped me to understand FP, Haskell LEARNED ME how to write good code”. Some developers say that learning Haskell is like learning programming again from scratch. I learned great stuff from Haskell, and it was easy and fun to get started with it. Learn You a Haskell for Great Good! is a great tutorial to get started with Haskell.\nLearn some FP language If you don’t like Haskell, don’t worry, you can learn another FP language. You can check Kotlin, Scala, F#, Clojure, Elixir, Erlang...\nIf you want to stick with JVM, then you can learn Kotlin, Scala, or Clojure. Kotlin and Scala support functional and OOP paradigms and Java developers can easily get started with them. Kotlin is a new language, Spring framework supports it, and some Java developers started switching to it. Because of those reasons, I suggest trying Kotlin.\nClojure is a modern Lisp variant that runs on JVM. It is useful to know that Lisp is the oldest FP language. Also, Uncle Bob is using Clojure.\nMy experience with Functional Programming To get familiar with FP, I studied and applied in practice FP concepts. The most important concepts that I learned are:\nImmutability - I have as many as possible immutable objects in my codebase. This leads to fewer places where I can change the state of the program. And that leads to fewer bugs. Referential transparency - I write as much as possible pure functions. Those functions are like mathematical functions. For the same input, they always have the same output. Pure and unpure functions - before FP, I was not aware of this concept. Now, I separate pure functions from unpure. It allowed me to easier test the code and improved my code reusability. Function Composition - promotes better code readability and it is easier to write code by composing functions. Curried Functions - brilliant concept, but it is not natural to use it in Java like in other FP languages. I don’t use them for now. Lazy evaluation - evaluate values when they are needed. Lambdas are the way to do a lazy evaluation in Java. Higher-Order functions - receive other functions as parameters in existing functions. Those functions are usually utility functions. Map, filter, reduce pattern - Java Stream API implements this pattern. Monads - helped me understand how to handle unpure functions safely. Optional class - FP provides an efficient solution on how to work with nullable objects. I always return the Optional object instead of null in a method that can return null. Railway programming - helped me understand how Stream API and Optional class works. Using FP in code doesn't prevent us, developers, from writing bad code. We still need to write unit tests, have a good understanding of our task and our codebase. We still need to apply all the best practices that we learned in the past. FP is promoting good practices and makes it easier for us developers to write good and maintainable code.\nI plan to further learn about FP and Java. I will continue to write posts on this subject. For updates, you can follow me on Twitter or LinkedIn.\n","link":"https://www.professionaldev.pro/post/java/start_fp_in_java/","section":"post","tags":["functional programming","java","learn functional programming","getting started with functional programming in java"],"title":"How do I become proficient with functional programming in Java"},{"body":"","link":"https://www.professionaldev.pro/tags/learn-functional-programming/","section":"tags","tags":null,"title":"learn functional programming"}]